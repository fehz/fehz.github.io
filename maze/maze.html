<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinthe</title>
    <style>
        canvas {
            background-color: gray;
        }
    </style>
</head>

<body onload="startGame()">
    <canvas id="playground" tabindex="1">

    </canvas>
    <p id="infos-block"></p>
    <button onclick="moveTo('R')">Move</button>
    <script>
        var devMode = true;
        var infosBlock = document.getElementById('infos-block');

        var gamesData;
        var context;
        var wall = new Image();
        wall.src = './assets/wall.png';
        var grass = new Image();
        grass.src = './assets/grass-2.png';
        var perso = new Image();
        perso.src = './assets/perso.png';
        var flowers = [];
        flowers[0] = new Image();
        flowers[0].src = './assets/flower-1.png';
        flowers[1] = new Image();
        flowers[1].src = './assets/flower-2.png';
        flowers[2] = new Image();
        flowers[2].src = './assets/flower-3.png';
        flowers[3] = new Image();
        flowers[3].src = './assets/flower-4.png';
        var gift = new Image();
        gift.src = './assets/gift.png';

        function initDatas() {
            gamesData = {
                maze: [
                    'XXXXXX........X',
                    '...XXX.XXXXXX.X',
                    'XX.XXX....XXXXX',
                    'XX.XXXXXX.XXXXX',
                    'XX...XXX....XXX',
                    'XXXX.XXX.XX.XXX',
                    'XXXX...X.XX....',
                    'XXXXXX...XX.XXX',
                    'XXX....XXXX..XX',
                    'XXX.XXXXXXXXXXX',
                ],
                startPosition: { x: 0, y: 1 },
                targetPosition: { x: 13, y: 1 },
                blockSize: 64,
                canMoveTo: function (position) {
                    try {
                        return '.' === this.maze[position.y][position.x];
                    }
                    catch (e) {
                        console.log("out of bound index");
                        return false;
                    }
                },
                actualPosition: { x: 0, y: 0 },
                canvasWidth: function () {
                    return this.blockSize * this.maze[0].length;
                },
                canvasHeight: function () {
                    return this.blockSize * this.maze.length;
                }
            }
            gamesData.actualPosition = gamesData.startPosition;
            const canvas = document.getElementById("playground");
            canvas.width = this.gamesData.canvasWidth();
            canvas.height = this.gamesData.canvasHeight();
            this.context = canvas.getContext("2d");

        }

        function startGame() {
            initDatas();
            initMaze();
            initEventListener();
        }

        function initMaze() {
            drawMaze();
            drawGift(this.gamesData.targetPosition);
            drawPerso(this.gamesData.startPosition);
        }

        function initEventListener() {
            document.addEventListener('keydown', function (event) {
                console.log(event);
                switch (event.key) {
                    case 'ArrowUp':
                    case 'z':
                        moveTo('U');
                        break;
                    case 'ArrowDown':
                    case 's':
                        moveTo('D');
                        break;
                    case 'ArrowLeft':
                    case 'q':
                        moveTo('L');
                        break;
                    case 'ArrowRight':
                    case 'd':
                        moveTo('R');
                        break;
                }
            }, false);
        }

        function updatePosition(persoPostion) {
            drawCase(this.gamesData.actualPosition, "gray");
            drawGift(this.gamesData.targetPosition);
            drawPerso(persoPostion);
        }


        function drawMaze() {
            for (let [i, row] of this.gamesData.maze.entries()) {
                for (let [j, elt] of row.split('').entries()) {
                    if (elt === 'X') {
                        drawImage({ x: j, y: i }, this.grass);
                        drawFlower({ x: j, y: i });
                    }
                    if (this.devMode) {
                this.context.textBaseline = 'top';
                this.context.fillStyle = 'black';
                this.context.fillText(`${j}x${i}`, j*this.gamesData.blockSize, i*this.gamesData.blockSize);
            }
                }

            }
        }
        drawFlower = (position) => {
            if (Math.random() < 0.3) {
                const flower = this.flowers[Math.floor(Math.random() * this.flowers.length)];
                const blockSize = this.gamesData.blockSize;
                this.context.drawImage(flower,
                    position.x * blockSize + (Math.random() * (blockSize - flower.width)),
                    position.y * blockSize + (Math.random() * (blockSize - flower.height)));
            }
        }

        drawPerso = (position) => {
            drawImage(position, this.perso);
        }

        drawGift = (position) => {
            drawImage(position, this.gift);
        }
        drawCase = (position, style) => {
            const blockSize = this.gamesData.blockSize;
            this.context.fillStyle = style;
            this.context.fillRect(position.x * blockSize, position.y * blockSize, blockSize, blockSize);
            if (this.devMode) {
                this.context.textBaseline = 'top';
                this.context.fillStyle = 'black';
                this.context.fillText(`${position.x}x${position.y}`, position.x * blockSize, position.y * blockSize);
            }
        }

        drawImage = (position, image) => {
            const blockSize = this.gamesData.blockSize;
            this.context.drawImage(image, position.x * blockSize, position.y * blockSize);
            if (this.devMode) {
                this.context.textBaseline = 'top';
                this.context.fillStyle = 'black';
                this.context.fillText(`${position.x}x${position.y}`, position.x * blockSize, position.y * blockSize);
            }
        }
        moveTo = (direction) => {
            var target = structuredClone(this.gamesData.actualPosition);
            switch (direction) {
                case 'R':
                    target.x++;
                    break;
                case 'L':
                    target.x--;
                    break;
                case 'U':
                    target.y--;
                    break;
                case 'D':
                    target.y++;
                    break;
            }

            if (this.gamesData.canMoveTo(target)) {
                updatePosition(target);
                this.gamesData.actualPosition = target;
                verifyWinCondition();
            }
        }
        verifyWinCondition = () => {
            if (this.gamesData.actualPosition.x === this.gamesData.targetPosition.x &&
                this.gamesData.actualPosition.y === this.gamesData.targetPosition.y
            ) {
                this.infosBlock.innerHTML = 'YOU WIN'
            }
        }
    </script>
</body>

</html>